// deno-lint-ignore-file
// This file is generated by `deno task generateWorkerManager`. DO NOT EDIT THIS FILE MANUALLY.
export default "/**\n * @module\n *\n * A proxy to spawn miniflare, as Miniflare is not available in Deno (https://github.com/cloudflare/workers-sdk/issues/6049).\n *\n * This file should be able to run in Node.js.\n */\n\nimport { Miniflare } from \"miniflare\";\nimport { getPort } from \"get-port-please\";\nimport process from \"node:process\";\nimport readline from \"node:readline\";\nimport type { InitialParentData, SerializedError } from \"./base.ts\";\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n});\n\nprocess.chdir(process.env.CROSSTEST_TEMPDIST!);\n\nconst mfInstances = new Map<string, Miniflare>();\nconst handleMfManagerMessage = async (\n  message: ToMfManagerMessage,\n): Promise<FromMfManagerMessage> => {\n  switch (message.type) {\n    case \"new\": {\n      const port = await getPort();\n      const mf = new Miniflare({\n        modules: true,\n        compatibilityFlags: [],\n        port,\n        scriptPath: message.path,\n      });\n      const id = crypto.randomUUID();\n      mfInstances.set(id, mf);\n\n      return { type: \"new\", id };\n    }\n    case \"start\": {\n      const mf = mfInstances.get(message.id);\n      if (!mf) {\n        throw new Error(`Invalid id: ${message.id}`);\n      }\n      const result = await mf.dispatchFetch(`http://localhost/`, {\n        method: \"POST\",\n        body: JSON.stringify(message.initialParentData),\n      });\n      console.warn(result);\n      return { type: \"start\" };\n    }\n    case \"kill\": {\n      const mf = mfInstances.get(message.id);\n      if (!mf) {\n        throw new Error(`Invalid id: ${message.id}`);\n      }\n      await mf.dispose();\n      mfInstances.delete(message.id);\n\n      return { type: \"kill\" };\n    }\n\n    case \"exit\":\n      if (mfInstances.size > 0) {\n        for (const mf of mfInstances.values()) {\n          await mf.dispose();\n        }\n      }\n\n      process.exit(0);\n      break;\n    default:\n      throw new Error(\n        `Unknown message type: ${(message as { type: string }).type}`,\n      );\n  }\n};\n\nfor await (const line of rl) {\n  const message: { nonce: string; data: ToMfManagerMessage } = JSON.parse(line);\n  try {\n    const response = await handleMfManagerMessage(message.data);\n    console.log(\"!\" + JSON.stringify({ nonce: message.nonce, ...response }));\n  } catch (error) {\n    if (error instanceof Error) {\n      console.log(\n        \"!\" +\n          JSON.stringify(\n            {\n              nonce: message.nonce,\n              type: \"error\",\n              error: {\n                type: \"error\",\n                message: error.message,\n                name: error.name,\n                stack: error.stack,\n              },\n            } satisfies FromMfManagerMessageError & { nonce: string },\n          ),\n      );\n    } else {\n      console.log(\n        \"!\" +\n          JSON.stringify({\n            nonce: message.nonce,\n            type: \"error\",\n            error: {\n              type: \"other\",\n              value: error,\n            },\n          }),\n      );\n    }\n  }\n}\nthrow new Error(\"Unreachable\");\n\nexport type ToMfManagerMessage =\n  | {\n    type: \"new\";\n    path: string;\n  }\n  | {\n    type: \"start\";\n    id: string;\n    initialParentData: InitialParentData;\n  }\n  | {\n    type: \"kill\";\n    id: string;\n  }\n  | {\n    type: \"exit\";\n  };\n\nexport type FromMfManagerMessage =\n  | {\n    type: \"new\";\n    id: string;\n  }\n  | {\n    type: \"start\";\n  }\n  | {\n    type: \"kill\";\n  }\n  | {\n    type: \"exit\";\n  };\n\nexport type FromMfManagerMessageError = {\n  type: \"error\";\n  error: SerializedError;\n};\n"